import argparse
from operator import attrgetter
from utils.utils import get_default_block_path
import os
from Ncut import Ncut
from sklearn.cluster import KMeans
from collections import namedtuple
from operator import attrgetter
import math
import subprocess
import seaborn as sns
import matplotlib.pyplot as plt


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--match", default=os.path.join(get_default_block_path(-1),
                                        "match.out"))
    parser.add_argument(
        "--img_list", default=os.path.join(get_default_block_path(-1),
                                           "image_list"))

    args = parser.parse_args()
    return args


def parse_match(pth):
    ret = []
    matchPair = namedtuple("matchPair", ['id1', 'id2', 'score'])
    with open(pth, "r") as f:
        lines = f.readlines()
        for line in lines:
            id1, id2, score = line.split()
            new_pair = matchPair(int(id1), int(id2), float(score))
            ret.append(new_pair)

    # sort match list by similarity score with decend order
    ret.sort(key=attrgetter('score'), reverse=True)

    return ret


def in_different_set(pair, set1, set2):
    id1 = pair.id1
    id2 = pair.id2
    if (id1 in set1 and id2 in set2) or\
            (id1 in set2 and id2 in set1):
        return True
    else:
        return False


def main():
    args = parse_args()
    """
    # 1. Image Clustering
    # create normalised cut object
    # input is the path to match.out file generated by libvot
    # output is a vector, softly separate the images into two cluster
    # need to use some other approach to hardly separate them, ex,
    # kmeans or thresholding
    """
    norm_cut = Ncut(args.match)
    ret = norm_cut.EigenSolver()
    # ret = ret.astype('float64')
    print(f"Ret max: {ret.max()}")
    print(f"Ret min: {ret.min()}")
    print(len(ret))
    print(f"Result: {ret}")
    ret = ret.reshape(-1, 1)
    sns.heatmap(ret)
    plt.savefig("heat.png")

    # parse image list file
    img_list = []
    with open(args.img_list, 'r') as f:
        lines = f.readlines()
        for line in lines:
            img_list.append(line[:-1])

    kmeans = KMeans(n_clusters=2)
    clust = kmeans.fit(ret)
    set1 = set()
    set2 = set()
    for idx, i in enumerate(clust.labels_):
        if i > 0:
            set1.add(idx)
        else:
            set2.add(idx)
    print(f"Number of image in set 1: {len(set1)}")
    print(f"Number of image in set 2: {len(set2)}")
    print(set1)
    print(set2)

    """
    # 2. Finding Anchor Images
    # sort image pairs with similarity score, if two images in a pair are in
    # different clusters and the similarity score is large enough, they can
    # be anchor images.
    """
    # parse match.out file
    match_list = parse_match(args.match)

    # set the threshold of anchor image
    sim_thresh = 0.1
    max_anchor_num = 20
    total_image_number = int(math.sqrt(len(match_list)))
    anchor_number = total_image_number * sim_thresh
    anchors = set()
    for pair in match_list:
        # print(pair.id1, pair.id2, pair.score)
        # if in_different_set(pair, set1, set2) and pair.score > sim_thresh:
        # if in_different_set(pair, set1, set2) and\
        #         pair.id1 not in anchors and pair.id2 not in anchors and\
        #         pair.score > 0:
        if in_different_set(pair, set1, set2) and pair.score > 0:
            anchors.add(pair.id1)
            anchors.add(pair.id2)
            # print(f"Add cut edge: {pair.id1:4d} <--> {pair.id2:4d},\t"
            #       f"score: {pair.score}")
            print(f"Cut edge: ({pair.id1}) {img_list[pair.id1]} <----> "
                  f"({pair.id2}) {img_list[pair.id2]},\tscore: {pair.score}")
            if len(anchors) > anchor_number:
                break
    print(f"Number of anchor images: {len(anchors)}")
    print(f"Anchors: {anchors}")

    """
    3. Get image index, separate images into two cluster with anchor images.
    """

    # print(img_list)

    # separate images
    pth = get_default_block_path(-1)
    block1_dir = os.path.join(pth, 'block1')
    block2_dir = os.path.join(pth, 'block2')
    if not os.path.exists(block1_dir):
        os.makedirs(block1_dir)
        os.makedirs(os.path.join(block1_dir, 'anchor'))
    if not os.path.exists(block2_dir):
        os.makedirs(block2_dir)
        os.makedirs(os.path.join(block2_dir, 'anchor'))

    for idx in anchors:
        img = img_list[idx]
        img_name = os.path.split(img)[-1]
        _ = subprocess.run(
            ['cp', img, os.path.join(block1_dir, 'anchor', img_name)])
        _ = subprocess.run(
            ['cp', img, os.path.join(block2_dir, 'anchor', img_name)])

    for idx in set1:
        img = img_list[idx]
        img_name = os.path.split(img)[-1]
        if idx not in anchors:
            ret = subprocess.run(
                ['cp', img, os.path.join(block1_dir, img_name)])

    for idx in set2:
        img = img_list[idx]
        img_name = os.path.split(img)[-1]
        if idx not in anchors:
            ret = subprocess.run(
                ['cp', img, os.path.join(block2_dir, img_name)])


if __name__ == "__main__":
    main()
